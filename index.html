<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DNS Check → Redirect</title>
<style>
  html,body { margin:0; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial }
  .wrap { max-width:720px; margin:12vh auto; padding:16px; text-align:center }
  .spinner { width:36px; height:36px; border:4px solid #eee; border-top-color:#555; border-radius:50%; margin:16px auto; animation:spin 1s linear infinite }
  @keyframes spin { to { transform:rotate(360deg) } }
  .small { color:#666; font-size:12px; margin-top:8px }
</style>
</head>
<body>
<div class="wrap">
  <h2>Checking your DNS…</h2>
  <div class="spinner" aria-hidden="true"></div>
  <div id="msg" class="small">Please wait, redirecting to the form.</div>
</div>

<script>
(async () => {
  const qs = new URLSearchParams(location.search);
  const debug = qs.get('debug') === '1';
  const setMsg = t => { const el = document.getElementById('msg'); if (el) el.textContent = t; };
  const canon = s => String(s || '').trim().replace(/\.$/, '').toLowerCase();

  // Inputs:
  // - jotform: FULL JotForm URL encoded once with encodeURIComponent (may have its own params)
  // - domain, expectedA (csv), expectedC, cnameHost (default 'www')
  // (Optional) jotform64: base64 of full JotForm URL (fallback if you prefer base64)
  let jotform = (qs.get('jotform') || '').trim();
  const jotform64 = qs.get('jotform64');
  const domain = (qs.get('domain') || '').trim();
  const expectedA = (qs.get('expectedA') || '').split(',').map(s => s.trim()).filter(Boolean);
  const expectedC = (qs.get('expectedC') || '').trim();
  const cnameHost = (qs.get('cnameHost') || 'www').trim() || 'www';

  // Optional: support base64 if you ever need it
  if (!jotform && jotform64) {
    try {
      jotform = decodeURIComponent(escape(atob(jotform64)));
    } catch {
      try { jotform = atob(jotform64); } catch { /* ignore */ }
    }
  }

  if (!jotform) { setMsg('Missing ?jotform= (encoded full JotForm URL)'); return; }
  if (!domain || (!expectedA.length && !expectedC)) { setMsg('Missing DNS params: need domain and expectedA and/or expectedC'); return; }

  // DNS-over-HTTPS helper (Cloudflare → Google fallback)
  async function doh(name, type) {
    const urls = [
      `https://cloudflare-dns.com/dns-query?ct=application/dns-json&name=${encodeURIComponent(name)}&type=${encodeURIComponent(type)}`,
      `https://dns.google/resolve?name=${encodeURIComponent(name)}&type=${encodeURIComponent(type)}`
    ];
    let lastErr;
    for (const url of urls) {
      try {
        const headers = url.includes('cloudflare-dns.com') ? { 'accept': 'application/dns-json' } : {};
        const r = await fetch(url, { mode: 'cors', headers });
        if (!r.ok) throw new Error(`HTTP ${r.status} from ${new URL(url).hostname}`);
        const j = await r.json();
        return (j.Answer || []).map(a => a.data);
      } catch (e) { lastErr = e; }
    }
    throw lastErr || new Error('All DoH providers failed');
  }

  // Run the DNS check
  let ok = false;
  try {
    const liveA = (await doh(domain, 'A')).filter(v => /^\d+\.\d+\.\d+\.\d+$/.test(v));
    const fqdn = (cnameHost === '@' ? domain : `${cnameHost}.${domain}`);
    let liveC = (await doh(fqdn, 'CNAME')).map(canon);

    const aMatch = expectedA.length ? expectedA.every(ip => liveA.includes(ip)) : null;
    let cMatch = expectedC ? liveC.includes(canon(expectedC)) : null;

    // OPTIONAL flattening tolerance: if no CNAME answer, consider host A vs expectedC A
    if (expectedC && cMatch === false && liveC.length === 0) {
      const hostA = (await doh(fqdn, 'A')).filter(v => /^\d+\.\d+\.\d+\.\d+$/.test(v));
      const expectedCA = (await doh(expectedC, 'A')).filter(v => /^\d+\.\d+\.\d+\.\d+$/.test(v));
      if (hostA.length && expectedCA.length) {
        const flattenedOK = expectedCA.every(ip => hostA.includes(ip));
        if (flattenedOK) cMatch = true;
      }
    }

    const checks = [aMatch, cMatch].filter(v => v !== null);
    ok = checks.length ? checks.every(Boolean) : false;

    if (debug) console.log({ domain, expectedA, expectedC, cnameHost, liveA, liveC, aMatch, cMatch, ok });
  } catch (e) {
    ok = false;
    if (debug) console.error('DoH error:', e);
  }

  // Decode JotForm URL (jotform param is expected to be encoded once)
  try { jotform = decodeURIComponent(jotform); } catch (_) { /* if already decoded, continue */ }

  let target;
  try { target = new URL(jotform); }
  catch { setMsg('Invalid JotForm URL'); return; }

  // Append dnsvalid
  target.searchParams.set('dnsvalid', ok ? 'yes' : 'no');

  // --- Ensure a complete, single-encoded dnscheckurl on the final JotForm URL ---
  (function ensureDnsCheckUrl(){
    // Try to reuse a stable token as cache-buster (rowid/cb) or fall back to timestamp
    const existingRowId = target.searchParams.get('rowid') || target.searchParams.get('cb') || '';
    const cb = existingRowId || String(Date.now());

    // Build decoded checker URL from authoritative params we just used
    let checker = `https://websmartzadmin.github.io/dnschecker?domain=${encodeURIComponent(domain)}`;
    if (expectedA.length) checker += `&expectedA=${encodeURIComponent(expectedA.join(','))}`;
    if (expectedC)        checker += `&expectedC=${encodeURIComponent(expectedC)}`;
    checker += `&cnameHost=${encodeURIComponent(cnameHost)}&cb=${encodeURIComponent(cb)}`;

    // Encode once for nesting
    const checkerEnc = encodeURIComponent(checker);

    // If caller supplied dnscheckurl, try to heal it; otherwise set the one we built
    const supplied = target.searchParams.get('dnscheckurl');
    if (!supplied) {
      target.searchParams.set('dnscheckurl', checkerEnc);
      return;
    }

    let healed = supplied;

    // If double-encoded (e.g., %253A), decode once
    if (/%25[0-9A-Fa-f]{2}/.test(supplied)) {
      try { healed = decodeURIComponent(supplied); } catch(_) {}
    }

    // If, after healing, it still lacks key params (only has domain), replace with our full one
    const hasAll = /(?:^|[?&])expectedA=|(?:^|[?&])expectedC=|(?:^|[?&])cnameHost=/.test(healed);
    if (!hasAll) {
      target.searchParams.set('dnscheckurl', checkerEnc);
    } else {
      // re-set the healed value (single-encoded if it was provided decoded)
      // If the healed value is still decoded, encode it once for safety
      const needsEncode = /https?:\/\//.test(healed);
      target.searchParams.set('dnscheckurl', needsEncode ? encodeURIComponent(healed) : healed);
    }
  })();

  setMsg(ok ? 'DNS valid — redirecting…' : 'DNS not valid — redirecting…');

  // Go!
  location.replace(target.toString());
})();
</script>
</body>
</html>








